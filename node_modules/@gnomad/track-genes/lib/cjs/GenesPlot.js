"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.GenesPlot = void 0;
var _propTypes = _interopRequireDefault(require("prop-types"));
var _react = _interopRequireDefault(require("react"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }
function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
var layoutRows = function layoutRows(genes, scalePosition) {
  if (genes.length === 0) {
    return [];
  }
  var sortedGenes = _toConsumableArray(genes).sort(function (gene1, gene2) {
    return gene1.start - gene2.start;
  });
  var rows = [[sortedGenes[0]]];
  for (var i = 1; i < sortedGenes.length; i += 1) {
    var gene = sortedGenes[i];
    var newRow = true;
    for (var rowIndex = 0; rowIndex < rows.length; rowIndex += 1) {
      var lastGeneInRow = rows[rowIndex][rows[rowIndex].length - 1];
      if (scalePosition(gene.start) - scalePosition(lastGeneInRow.stop) > 60) {
        rows[rowIndex].push(gene);
        newRow = false;
        break;
      }
    }
    if (newRow) {
      rows.push([gene]);
    }
  }
  return rows;
};
var featureAttributes = {
  exon: {
    fill: '#bdbdbd',
    height: 6
  },
  CDS: {
    fill: '#424242',
    height: 16
  },
  UTR: {
    fill: '#424242',
    height: 6
  }
};
var featureTypeOrder = {
  exon: 0,
  UTR: 1,
  CDS: 2
};
var featureTypeCompareFn = function featureTypeCompareFn(r1, r2) {
  return featureTypeOrder[r1.feature_type] - featureTypeOrder[r2.feature_type];
};
var isCodingGene = function isCodingGene(gene) {
  return gene.exons.some(function (exon) {
    return exon.feature_type === 'CDS';
  });
};
var GenesPlot = function GenesPlot(_ref) {
  var genes = _ref.genes,
    includeNonCodingGenes = _ref.includeNonCodingGenes,
    renderGeneLabel = _ref.renderGeneLabel,
    scalePosition = _ref.scalePosition,
    width = _ref.width;
  var rows = layoutRows(includeNonCodingGenes ? genes : genes.filter(isCodingGene), scalePosition);
  var rowHeight = 50;
  return /*#__PURE__*/_react.default.createElement("svg", {
    height: rowHeight * rows.length,
    width: width
  }, rows.map(function (track, trackNumber) {
    return track.map(function (gene) {
      var labelY = rowHeight * trackNumber + 33;
      var exonsYPosition = rowHeight * trackNumber + 8;
      var geneStart = scalePosition(gene.start);
      var geneStop = scalePosition(gene.stop);
      return /*#__PURE__*/_react.default.createElement("g", {
        key: gene.gene_id
      }, /*#__PURE__*/_react.default.createElement("g", {
        transform: "translate(".concat((geneStart + geneStop) / 2, ",").concat(labelY, ")")
      }, renderGeneLabel(gene)), /*#__PURE__*/_react.default.createElement("line", {
        x1: geneStart,
        x2: geneStop,
        y1: exonsYPosition,
        y2: exonsYPosition,
        stroke: "#424242",
        strokeWidth: 1
      }), _toConsumableArray(gene.exons).sort(featureTypeCompareFn).map(function (exon) {
        var exonStart = scalePosition(exon.start);
        var exonStop = scalePosition(exon.stop);
        var _featureAttributes$ex = featureAttributes[exon.feature_type],
          fill = _featureAttributes$ex.fill,
          exonHeight = _featureAttributes$ex.height;
        return /*#__PURE__*/_react.default.createElement("rect", {
          key: "".concat(gene.gene_id, "-").concat(exon.feature_type, "-").concat(exon.start, "-").concat(exon.stop),
          x: exonStart,
          y: rowHeight * trackNumber + (16 - exonHeight) / 2,
          width: exonStop - exonStart,
          height: exonHeight,
          fill: fill,
          stroke: fill
        });
      }));
    });
  }));
};
exports.GenesPlot = GenesPlot;
GenesPlot.propTypes = {
  genes: _propTypes.default.arrayOf(_propTypes.default.shape({
    gene_id: _propTypes.default.string.isRequired,
    start: _propTypes.default.number.isRequired,
    stop: _propTypes.default.number.isRequired,
    exons: _propTypes.default.arrayOf(_propTypes.default.shape({
      feature_type: _propTypes.default.oneOf(['CDS', 'exon', 'UTR']).isRequired,
      start: _propTypes.default.number.isRequired,
      stop: _propTypes.default.number.isRequired
    })).isRequired
  })).isRequired,
  includeNonCodingGenes: _propTypes.default.bool,
  renderGeneLabel: _propTypes.default.func,
  scalePosition: _propTypes.default.func.isRequired,
  width: _propTypes.default.number.isRequired
};
GenesPlot.defaultProps = {
  includeNonCodingGenes: false,
  renderGeneLabel: function renderGeneLabel(gene) {
    return /*#__PURE__*/_react.default.createElement("text", {
      textAnchor: "middle"
    }, gene.symbol);
  }
};