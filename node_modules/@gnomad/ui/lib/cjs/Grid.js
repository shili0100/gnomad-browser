"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.GridHeadingTooltip = exports.Grid = void 0;
var _polished = require("polished");
var _propTypes = _interopRequireDefault(require("prop-types"));
var _react = _interopRequireWildcard(require("react"));
var _styledComponents = _interopRequireWildcard(require("styled-components"));
var _reactSizeme = require("react-sizeme");
var _reactWindow = require("react-window");
var _TooltipAnchor = require("./tooltip/TooltipAnchor");
var _TooltipHint = require("./tooltip/TooltipHint");
var _excluded = ["cellData", "columns", "data", "numRowsRendered", "onHoverRow", "onRequestSort", "onScroll", "onVisibleRowsChange", "rowHeight", "rowKey", "shouldHighlightRow", "sortKey", "sortOrder"];
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }
function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
var baseRowStyle = (0, _styledComponents.css)(["display:flex;flex-direction:row;align-items:stretch;box-sizing:border-box;border-top:1px solid #e0e0e0;"]);
var baseCellStyle = (0, _styledComponents.css)(["display:flex;flex-grow:0;flex-shrink:0;align-items:center;box-sizing:border-box;width:", "px;padding:0 0.5em;outline:none;&:focus{box-shadow:inset 0 0 0 2px ", ";}"], function (props) {
  return props.width;
}, (0, _polished.transparentize)(0.5, '#428bca'));
var GridWrapper = _styledComponents.default.div.withConfig({
  displayName: "Grid__GridWrapper",
  componentId: "sc-1krvipn-0"
})(["width:100%;.grid-row{", ";&.grid-row-stripe{background:#fff;}&.grid-row-highlight{box-shadow:inset 0 0 0 1px #000;}}.grid-cell{", ";}.grid-cell-content{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;}"], baseRowStyle, baseCellStyle);
var GridHorizontalViewport = _styledComponents.default.div.withConfig({
  displayName: "Grid__GridHorizontalViewport",
  componentId: "sc-1krvipn-1"
})(["overflow-x:auto;"]);
var HeaderRow = _styledComponents.default.div.withConfig({
  displayName: "Grid__HeaderRow",
  componentId: "sc-1krvipn-2"
})(["", ";border-top:none;border-bottom:1px solid #e0e0e0;"], baseRowStyle);
var ColumnHeader = _styledComponents.default.div.withConfig({
  displayName: "Grid__ColumnHeader",
  componentId: "sc-1krvipn-3"
})(["", ";padding:0.25em 20px 0.25em 0.5em;background-position:center right;background-repeat:no-repeat;font-weight:bold;&[aria-sort='ascending']{background-image:url('data:image/gif;base64,R0lGODlhFQAEAIAAACMtMP///yH5BAEAAAEALAAAAAAVAAQAAAINjI8Bya2wnINUMopZAQA7');}&[aria-sort='descending']{background-image:url('data:image/gif;base64,R0lGODlhFQAEAIAAACMtMP///yH5BAEAAAEALAAAAAAVAAQAAAINjB+gC+jP2ptn0WskLQA7');}&:focus-within{box-shadow:inset 0 0 0 2px ", ";}button{padding:0;border:none;background:none;color:inherit;cursor:pointer;font:inherit;outline:none;user-select:none;}"], baseCellStyle, (0, _polished.transparentize)(0.5, '#428bca'));
var HeadingTooltipWrapper = _styledComponents.default.span.withConfig({
  displayName: "Grid__HeadingTooltipWrapper",
  componentId: "sc-1krvipn-4"
})(["max-width:300px;line-height:1.5;"]);
var GridHeadingTooltip = function GridHeadingTooltip(_ref) {
  var tooltip = _ref.tooltip;
  return /*#__PURE__*/_react.default.createElement(HeadingTooltipWrapper, null, tooltip);
};
exports.GridHeadingTooltip = GridHeadingTooltip;
GridHeadingTooltip.propTypes = {
  tooltip: _propTypes.default.string.isRequired
};
var DataRow = function DataRow(_ref2) {
  var dataRowIndex = _ref2.index,
    _ref2$data = _ref2.data,
    cellData = _ref2$data.cellData,
    columns = _ref2$data.columns,
    columnWidths = _ref2$data.columnWidths,
    data = _ref2$data.data,
    focusedCell = _ref2$data.focusedCell,
    onMouseEnter = _ref2$data.onMouseEnter,
    shouldHighlightRow = _ref2$data.shouldHighlightRow,
    style = _ref2.style;
  var rowData = data[dataRowIndex];
  var rowIndex = dataRowIndex + 1; // + 1 for header row
  return (
    /*#__PURE__*/
    // eslint-disable-next-line jsx-a11y/interactive-supports-focus
    _react.default.createElement("div", {
      "aria-rowindex": rowIndex + 1,
      className: "grid-row ".concat(dataRowIndex % 2 === 0 ? 'grid-row-stripe' : '', " ").concat(shouldHighlightRow(rowData) ? 'grid-row-highlight' : ''),
      onMouseEnter: onMouseEnter,
      role: "row",
      style: style
    }, columns.map(function (column, columnIndex) {
      return /*#__PURE__*/_react.default.createElement("div", {
        key: column.key,
        "aria-colindex": columnIndex + 1,
        className: "grid-cell",
        "data-cell": "".concat(columnIndex, ",").concat(rowIndex),
        role: column.isRowHeader ? 'rowheader' : 'gridcell',
        tabIndex: columnIndex === focusedCell.columnIndex && rowIndex === focusedCell.rowIndex ? 0 : -1,
        style: {
          width: columnWidths[columnIndex]
        }
      }, column.render(rowData, column.key, cellData));
    }))
  );
};
DataRow.propTypes = {
  data: _propTypes.default.shape({
    cellData: _propTypes.default.object,
    // eslint-disable-line react/forbid-prop-types
    columns: _propTypes.default.arrayOf(_propTypes.default.shape({
      key: _propTypes.default.string.isRequired,
      isRowHeader: _propTypes.default.bool,
      render: _propTypes.default.func.isRequired
    })).isRequired,
    columnWidths: _propTypes.default.arrayOf(_propTypes.default.number.isRequired),
    data: _propTypes.default.arrayOf(_propTypes.default.any).isRequired,
    focusedCell: _propTypes.default.shape({
      columnIndex: _propTypes.default.number.isRequired,
      rowIndex: _propTypes.default.number.isRequired
    }).isRequired,
    onMouseEnter: _propTypes.default.func.isRequired,
    shouldHighlightRow: _propTypes.default.func.isRequired
  }).isRequired,
  index: _propTypes.default.number.isRequired,
  style: _propTypes.default.object.isRequired // eslint-disable-line react/forbid-prop-types
};
var Grid = /*#__PURE__*/function (_Component) {
  _inherits(Grid, _Component);
  var _super = _createSuper(Grid);
  function Grid() {
    var _this;
    _classCallCheck(this, Grid);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    /* eslint-disable react/sort-comp */
    _defineProperty(_assertThisInitialized(_this), "focusedCell", {
      columnIndex: 0,
      rowIndex: 0
    });
    _defineProperty(_assertThisInitialized(_this), "focusedElement", null);
    _defineProperty(_assertThisInitialized(_this), "gridElement", /*#__PURE__*/_react.default.createRef());
    _defineProperty(_assertThisInitialized(_this), "list", /*#__PURE__*/_react.default.createRef());
    /* eslint-enable react/sort-comp */
    // https://www.w3.org/TR/wai-aria-practices/#kbd_roving_tabindex
    _defineProperty(_assertThisInitialized(_this), "onFocus", function (e) {
      var targetElement = e.target;
      if (targetElement === _this.gridElement.current) {
        _this.moveFocusToCell(_this.focusedCell.columnIndex, _this.focusedCell.rowIndex);
        return;
      }
      var containingCell = targetElement.closest('[data-cell]');
      var _containingCell$datas = containingCell.dataset.cell.split(',').map(Number),
        _containingCell$datas2 = _slicedToArray(_containingCell$datas, 2),
        columnIndex = _containingCell$datas2[0],
        rowIndex = _containingCell$datas2[1];

      // Place tabindex=0 on the currently focused element, remove it from other elements
      _this.gridElement.current.setAttribute('tabindex', -1);
      var previouslyFocusedElement = _this.focusedElement;
      if (previouslyFocusedElement) {
        previouslyFocusedElement.setAttribute('tabindex', -1);
      }
      targetElement.setAttribute('tabindex', 0);
      _this.focusedCell = {
        columnIndex: columnIndex,
        rowIndex: rowIndex
      };
      _this.focusedElement = targetElement;
    });
    _defineProperty(_assertThisInitialized(_this), "onItemsRendered", function (_ref3) {
      var visibleStartIndex = _ref3.visibleStartIndex,
        visibleStopIndex = _ref3.visibleStopIndex;
      // If the focused cell is scrolled out of view, place tabindex=0 back on the grid.
      // Since the focused cell's element (the only one with tabindex=0) is destroyed,
      // no element in the grid will be tabbable.
      // After this, onFocus will move focus back to the correct cell when the grid is next focused.
      var focusedDataRowIndex = _this.focusedCell.rowIndex - 1;
      if (focusedDataRowIndex < visibleStartIndex || focusedDataRowIndex > visibleStopIndex) {
        if (_this.focusedElement) {
          _this.focusedElement = null;
        }
        _this.gridElement.current.setAttribute('tabindex', 0);
      }
      var onVisibleRowsChange = _this.props.onVisibleRowsChange;
      onVisibleRowsChange({
        startIndex: visibleStartIndex,
        stopIndex: visibleStopIndex
      });
    });
    _defineProperty(_assertThisInitialized(_this), "onMouseEnterRow", function (e) {
      // -2 because a) aria-rowindex starts at 1 and b) to skip the header row
      var rowIndex = Number(e.currentTarget.getAttribute('aria-rowindex')) - 2;
      var onHoverRow = _this.props.onHoverRow;
      onHoverRow(rowIndex);
    });
    _defineProperty(_assertThisInitialized(_this), "onKeyDown", function (e) {
      var _this$props = _this.props,
        columns = _this$props.columns,
        data = _this$props.data;
      var _this$focusedCell = _this.focusedCell,
        columnIndex = _this$focusedCell.columnIndex,
        rowIndex = _this$focusedCell.rowIndex;
      var numColumns = columns.length;
      var numRows = data.length + 1;

      // TODO: Handle more keys
      // See "Keyboard Interaction for Data Grids" https://www.w3.org/TR/wai-aria-practices/#grid
      switch (e.key) {
        case ' ':
          // prevent space key from scrolling
          if (e.target.matches('[data-cell]')) {
            e.preventDefault();
          }
          break;
        case 'ArrowUp':
          if (rowIndex > 0) {
            _this.moveFocusToCell(columnIndex, rowIndex - 1);
          }
          e.preventDefault(); // prevent scroll (handled by moveFocusToCell)
          break;
        case 'ArrowDown':
          if (rowIndex < numRows - 1) {
            _this.moveFocusToCell(columnIndex, rowIndex + 1);
          }
          e.preventDefault(); // prevent scroll (handled by moveFocusToCell)
          break;
        case 'ArrowLeft':
          if (columnIndex > 0) {
            _this.moveFocusToCell(columnIndex - 1, rowIndex);
          }
          e.preventDefault(); // prevent scroll (handled by moveFocusToCell)
          break;
        case 'ArrowRight':
          if (columnIndex < numColumns - 1) {
            _this.moveFocusToCell(columnIndex + 1, rowIndex);
          }
          e.preventDefault(); // prevent scroll (handled by moveFocusToCell)
          break;
        default:
      }
    });
    return _this;
  }
  _createClass(Grid, [{
    key: "moveFocusToCell",
    value: function moveFocusToCell(columnIndex, rowIndex) {
      var _this2 = this;
      if (rowIndex !== 0) {
        this.list.current.scrollToItem(rowIndex - 1);
      }
      setTimeout(function () {
        // https://www.w3.org/TR/wai-aria-practices/#gridNav_focus
        var cellElement = _this2.gridElement.current.querySelector("[data-cell=\"".concat(columnIndex, ",").concat(rowIndex, "\"]"));

        // Note: supporting widgets that use arrow keys (such as text inputs or select menus)
        // will require changes to the Grid component.
        // See "Editing and Navigating Inside a Cell" https://www.w3.org/TR/wai-aria-practices/#gridNav_focus
        var controlElement = cellElement.querySelector('a, button');
        if (controlElement) {
          controlElement.focus();
        } else {
          cellElement.focus();
        }
      }, 0);
    }
  }, {
    key: "scrollTo",
    value: function scrollTo(scrollOffset) {
      this.list.current.scrollTo(scrollOffset);
    }
  }, {
    key: "scrollToDataRow",
    value: function scrollToDataRow(dataRowIndex) {
      // Data row indices are off by one from grid row indices since grid row indices include header row
      this.list.current.scrollToItem(dataRowIndex);
    }
  }, {
    key: "render",
    value: function render() {
      var _this3 = this;
      var _this$props2 = this.props,
        cellData = _this$props2.cellData,
        inputColumns = _this$props2.columns,
        data = _this$props2.data,
        numRowsRendered = _this$props2.numRowsRendered,
        onHoverRow = _this$props2.onHoverRow,
        onRequestSort = _this$props2.onRequestSort,
        onScroll = _this$props2.onScroll,
        onVisibleRowsChange = _this$props2.onVisibleRowsChange,
        rowHeight = _this$props2.rowHeight,
        rowKey = _this$props2.rowKey,
        shouldHighlightRow = _this$props2.shouldHighlightRow,
        sortKey = _this$props2.sortKey,
        sortOrder = _this$props2.sortOrder,
        rest = _objectWithoutProperties(_this$props2, _excluded);
      var columns = inputColumns.map(function (column) {
        var columnDefaults = {
          grow: 1,
          heading: column.key,
          tooltip: undefined,
          isRowHeader: false,
          isSortable: false,
          minWidth: 100,
          render: function render(rowData) {
            return /*#__PURE__*/_react.default.createElement("div", {
              className: "grid-cell-content"
            }, rowData[column.key]);
          }
        };
        return _objectSpread(_objectSpread({}, columnDefaults), column);
      });
      var ariaSortAttr = function ariaSortAttr(column) {
        if (!column.isSortable) {
          return undefined;
        }
        if (column.key !== sortKey) {
          return 'none';
        }
        return sortOrder;
      };
      return /*#__PURE__*/_react.default.createElement(GridWrapper, _extends({}, rest, {
        "aria-colcount": columns.length,
        "aria-rowcount": data.length + 1,
        ref: this.gridElement,
        role: "grid",
        tabIndex: 0,
        onFocus: this.onFocus,
        onKeyDown: this.onKeyDown,
        onMouseLeave: function onMouseLeave() {
          onHoverRow(null);
        }
      }), /*#__PURE__*/_react.default.createElement(_reactSizeme.SizeMe, null, function (_ref4) {
        var size = _ref4.size;
        var availableWidth = size.width;
        var minGridWidth = columns.reduce(function (sum, col) {
          return sum + col.minWidth;
        }, 0);
        var remainingWidth = Math.max(availableWidth - minGridWidth, 0);
        var totalGrowFactors = columns.reduce(function (sum, col) {
          return sum + col.grow;
        }, 0) || 1;
        var gridWidth = Math.max(availableWidth, minGridWidth);
        var columnWidths = columns.map(function (col) {
          return col.minWidth + col.grow / totalGrowFactors * remainingWidth;
        });
        return /*#__PURE__*/_react.default.createElement(GridHorizontalViewport, null, /*#__PURE__*/_react.default.createElement(HeaderRow, {
          "aria-rowindex": 1,
          height: rowHeight,
          role: "row"
        }, columns.map(function (column, columnIndex) {
          var content = column.heading;
          if (column.tooltip) {
            content = /*#__PURE__*/_react.default.createElement(_TooltipHint.TooltipHint, null, content);
          }
          if (column.isSortable) {
            content = /*#__PURE__*/_react.default.createElement("button", {
              tabIndex: -1,
              type: "button",
              onClick: function onClick() {
                return onRequestSort(column.key);
              }
            }, content);
          } else {
            content = /*#__PURE__*/_react.default.createElement("span", null, content);
          }
          if (column.tooltip) {
            content = /*#__PURE__*/_react.default.createElement(_TooltipAnchor.TooltipAnchor, {
              tooltip: column.tooltip,
              tooltipComponent: GridHeadingTooltip
            }, content);
          }
          return /*#__PURE__*/_react.default.createElement(ColumnHeader, {
            key: column.key,
            "aria-colindex": columnIndex + 1,
            "aria-sort": ariaSortAttr(column),
            "data-cell": "".concat(columnIndex, ",0"),
            role: "columnheader",
            tabIndex: -1,
            width: columnWidths[columnIndex]
          }, content);
        })), /*#__PURE__*/_react.default.createElement(_reactWindow.FixedSizeList
        // With height = numRowsRendered * rowHeight, when scrolled to an offset
        // which is an exact multiple of rowHeight, onItemsRendered's stopIndex
        // will be the index of the row after the last row visible. Subtracting
        // one pixel from the height prevents this.
        , {
          height: numRowsRendered * rowHeight - 1,
          itemCount: data.length,
          itemData: {
            cellData: cellData,
            columns: columns,
            columnWidths: columnWidths,
            data: data,
            focusedCell: _this3.focusedCell,
            onMouseEnter: _this3.onMouseEnterRow,
            shouldHighlightRow: shouldHighlightRow
          },
          itemKey: function itemKey(rowIndex) {
            return rowKey(data[rowIndex]);
          },
          itemSize: rowHeight,
          overscanCount: 10,
          ref: _this3.list,
          style: {
            overflowX: 'hidden'
          },
          width: gridWidth,
          onItemsRendered: _this3.onItemsRendered,
          onScroll: onScroll
        }, DataRow));
      }));
    }
  }]);
  return Grid;
}(_react.Component);
exports.Grid = Grid;
_defineProperty(Grid, "propTypes", {
  columns: _propTypes.default.arrayOf(_propTypes.default.shape({
    heading: _propTypes.default.string,
    key: _propTypes.default.string.isRequired,
    isRowHeader: _propTypes.default.bool,
    isSortable: _propTypes.default.bool,
    minWidth: _propTypes.default.number,
    render: _propTypes.default.func,
    tooltip: _propTypes.default.string
  })).isRequired,
  cellData: _propTypes.default.object,
  // eslint-disable-line react/forbid-prop-types
  data: _propTypes.default.arrayOf(_propTypes.default.any).isRequired,
  numRowsRendered: _propTypes.default.number,
  onHoverRow: _propTypes.default.func,
  onRequestSort: _propTypes.default.func,
  onScroll: _propTypes.default.func,
  onVisibleRowsChange: _propTypes.default.func,
  rowHeight: _propTypes.default.number,
  rowKey: _propTypes.default.func,
  shouldHighlightRow: _propTypes.default.func,
  sortKey: _propTypes.default.string,
  sortOrder: _propTypes.default.oneOf(['ascending', 'descending'])
});
_defineProperty(Grid, "defaultProps", {
  cellData: {},
  numRowsRendered: 20,
  onHoverRow: function onHoverRow() {},
  onRequestSort: undefined,
  onScroll: function onScroll() {},
  onVisibleRowsChange: function onVisibleRowsChange() {},
  rowHeight: 25,
  rowKey: function rowKey(rowData) {
    return rowData.key;
  },
  shouldHighlightRow: function shouldHighlightRow() {
    return false;
  },
  sortKey: undefined,
  sortOrder: 'ascending'
});